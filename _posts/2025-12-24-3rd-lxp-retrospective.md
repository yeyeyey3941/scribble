---
layout: post
title:  "LearnFlow 프로젝트 회고 - Lecture 도메인 설계와 성능 최적화"
date:   2025-12-24 21:00:00 +0900
categories: "project"
---

# LearnFlow 프로젝트 회고

## 개요

LearnFlow(Learning Experience Platform) 프로젝트에서 **Lecture 도메인**을 담당하여 설계부터 구현까지 전 과정을 경험했다.

- **담당 범위**: Lecture 도메인 설계 및 API 개발
- **추가 작업**: 커리큘럼(Chapter/Lesson) 구조 데이터 모델링, 강의 통계 관리 로직 구현
- **기간**: 2025.12.01 ~ 2025.12.15 (1차 스프린트)
- **참여 인원**: 백엔드 5명, 프론트엔드 3명
- **기술 스택**: Java 17, Spring Boot 3.5.8, Spring Data JPA, MySQL, Spring Security + JWT, GCP Storage

## Lecture 도메인의 역할

Lecture 도메인은 LXP 시스템에서 **강의 커리큘럼을 관리하고 학습 콘텐츠를 제공**하는 핵심 도메인이다.

**주요 역할**:
- 강사가 강의를 생성하고 Chapter-Lesson 계층 구조로 커리큘럼 구성
- 강의 상태 관리 (비공개/공개) 및 공개 조건 검증
- 강의 통계 데이터 관리 (평점, 수강생 수)
- Content 도메인(비디오/썸네일)과 Enrollment 도메인(수강)과의 연동
- 카테고리, 난이도, 정렬 순에 따른 강의 목록 조회

## 나의 담당 기능

### 1. Lecture 도메인 구현

#### 강의 커리큘럼 관리 (CRUD)
- **도메인 모델 설계**
  - `Lecture` 엔티티: 강의의 기본 정보 (제목, 설명, 카테고리, 난이도 등)
  - `Chapter` 엔티티: 강의 내 챕터 단위 구성
  - `Lesson` 엔티티: 챕터 내 개별 레슨 (Type: VIDEO, QUIZ)
  - 계층 구조: Lecture → Chapter → Lesson (1:N 관계)

- **일괄 생성 로직**
  - `LectureFullCreateRequest` DTO를 통해 한 번의 요청으로 전체 커리큘럼 생성
  - JPA의 `CascadeType.ALL`과 `orphanRemoval=true`를 활용하여 생명주기 관리
  - 트랜잭션 내에서 일관성 보장

- **커리큘럼 수정**
  - 현재는 `orphanRemoval`을 사용하여 전체 삭제 후 재생성 방식
  - 문제점 인지: `CompletedLesson`(수강 기록)의 참조 무결성 이슈
  - 개선 계획: 개별 Chapter/Lesson 단위의 CUD API로 분리 (2차 스프린트 목표)

#### 강의 상태 관리
- **상태 Enum 설계**
  - `UNPUBLISHED`: 비공개 상태 (초기 생성 시)
  - `PUBLISHED`: 공개 상태 (학습자에게 노출)

- **공개 조건 검증**
  - 최소 1개 이상의 레슨이 있어야 공개 가능
  - Service Layer에서 비즈니스 로직 검증
  - 상태 변경 시 유효성 검사 수행

#### 통계 분리 설계
- **LectureStatistic 엔티티 분리**
  - `Lecture`와 1:1 Weak Reference 관계
  - 통계 데이터: `enrollmentCount`(수강생 수), `ratingAverage`(평균 평점)
  - 분리 이유: 조회 빈도가 높은 `Lecture` 테이블과 쓰기 빈도가 높은 `Statistic` 테이블의 Lock 경합 최소화

- **성능 최적화 전략**
  - `enrollment_count`, `rating_average` 컬럼에 인덱스 적용
  - 인기순/평점순 정렬 성능 확보
  - 통계 업데이트 시 `Lecture` 테이블에 Lock이 걸리지 않음

#### 검색 및 필터링
- **목록 조회 기능**
  - 카테고리별 필터링
  - 난이도별 필터링
  - 정렬 옵션: 인기순(수강생 수), 최신순(생성일), 평점순

- **Repository 설계**
  - `LectureRepository`: 동적 쿼리 생성 (Specification 또는 QueryDSL 활용 가능)
  - 페이징 처리 지원

#### Service Layer 설계
- **LectureService 구현**
  - `createLecture()`: 강의 및 커리큘럼 일괄 생성
  - `updateLecture()`: 강의 정보 수정
  - `publishLecture()`: 강의 공개 처리 (조건 검증 포함)
  - `getLectureList()`: 필터링 및 정렬된 목록 조회
  - `getLectureDetail()`: 강의 상세 정보 조회

- **Repository 설계**
  - `LectureRepository`: 기본 CRUD 및 커스텀 쿼리
  - `LectureStatisticRepository`: 통계 데이터 조회 및 업데이트
  - `ChapterRepository`, `LessonRepository`: 계층 구조 관리

### 2. 성능 최적화 작업

#### N+1 문제 해결
- **문제 상황**
  - 강의 목록 조회 시, 각 강의에 연결된 `Thumbnail`과 `LectureStatistic`을 가져오기 위해 강의 수(N)만큼 추가 쿼리 발생
  - 초기 쿼리 횟수: `1 + N + N` (Lecture 조회 + Thumbnail N회 + Statistic N회)

- **해결 전략**
  1. Repository에서 `Page<Lecture>`를 먼저 조회
  2. 조회된 Lecture ID 목록(`List<Long>`)을 추출
  3. `findAllById`를 사용하여 연관된 통계 데이터를 한 번의 쿼리(IN 절)로 조회
  4. Application Layer에서 Map으로 변환하여 매핑
  5. `@BatchSize` 설정으로 추가 최적화

- **최종 성능 변화**
  - 쿼리 횟수: `1 + N + N` → `1 + 1 + 1`로 감소
  - 대량 데이터 조회 시 성능 향상 체감

#### 인덱스 전략
- **적용 인덱스**
  - `LectureStatistic.enrollment_count`: 인기순 정렬 성능
  - `LectureStatistic.rating_average`: 평점순 정렬 성능
  - `Lecture.created_at`: 최신순 정렬 성능

- **정규화**
  - `Category`, `LectureLevel` 등을 Enum 및 별도 테이블로 관리
  - 중복 데이터 최소화

### 3. 도메인 간 연동

#### Lecture ↔ Content 연동
- **Thumbnail 연동**
  - 강의 썸네일 이미지 관리
  - GCP Storage 연동을 통한 실제 미디어 서비스 기반 마련
  - Content 도메인과의 연동 설계

#### Lecture ↔ Enrollment 연동
- **수강생 수 통계**
  - Enrollment 도메인에서 수강 등록 시 `LectureStatistic.enrollmentCount` 업데이트
  - 도메인 간 이벤트 기반 통신 고려 (향후 개선)

## 핵심 설계 결정

### 1. 도메인 모델 구조

```
Lecture (Aggregate Root)
├─ Chapter (1:N) - 챕터
│  └─ Lesson (1:N) - 레슨 (Type: VIDEO, QUIZ)
├─ LectureStatistic (1:1 Weak Reference) - 통계 데이터
└─ Thumbnail (1:1) - 썸네일 이미지
```

**설계 이유**:
- Lecture를 Aggregate Root로 설정
- Chapter와 Lesson의 생명주기를 Lecture가 관리
- `CascadeType.ALL`과 `orphanRemoval=true`로 일관성 보장
- 통계 데이터 분리로 성능 최적화

### 2. 통계 분리 전략

**LectureStatistic 분리**:
- `Lecture`와 1:1 Weak Reference 관계
- 조회 빈도가 높은 `Lecture` 테이블과 쓰기 빈도가 높은 `Statistic` 테이블 분리
- DB Lock 경합 최소화

**장점**:
- 통계 업데이트 시 `Lecture` 테이블에 Lock이 걸리지 않음
- 조회 성능 향상
- 확장성: 향후 통계 데이터 추가 시 영향 최소화

### 3. 아키텍처 선택

**Monolithic 구조 선택**:
- 초기 설계에서 간단한 구조의 프로젝트를 아키텍처에 너무 많은 시간을 쏟기보다, 기능 구현을 우선
- 리팩토링을 통해 재조립 후 확장이 더 장점이 있다고 판단

**확장성 고려**:
- 추후 MSA 전환을 고려하여 도메인 간 결합도를 낮추기 위해 `Lecture`, `Content`, `Enrollment`를 논리적으로 분리
- 초기 개발 속도를 위해 Monolithic으로 구성
- 리팩토링을 통해 확장성을 위한 구조 개선 계획

**데이터 무결성**:
- RDBMS(MySQL)와 JPA를 사용하여 복잡한 커리큘럼 구조(Lecture-Chapter-Lesson)의 트랜잭션 일관성 보장
- 구현 과정에서 복잡도를 고려하여 다음 스프린트(or 중간 리팩토링 과정)에서 분리 고려

## 학습 내용

### N+1 문제 해결 전략

**문제 인식**:
- 강의 목록 조회 시 연관된 데이터를 가져오는 과정에서 N+1 문제 발생
- 대량 데이터 조회 시 성능 저하 체감

**해결 방법**:
- Repository에서 ID 목록을 추출하여 IN 절로 한 번에 조회
- Application Layer에서 Map으로 변환하여 매핑
- `@BatchSize` 설정으로 추가 최적화

**배운 점**:
- JPA의 연관관계 조회 시 발생할 수 있는 성능 이슈
- 쿼리 최적화를 위한 전략 수립의 중요성
- Application Layer에서의 데이터 매핑 기법

### 통계 데이터 분리로 인한 성능 개선

**배경**:
- 강의 조회 시 잦은 업데이트가 발생하는 통계 데이터로 인한 Lock 경합 문제
- 조회 성능과 쓰기 성능의 트레이드오프

**해결**:
- 통계 데이터를 별도 엔티티로 분리
- Weak Reference로 연결하여 독립적인 생명주기 관리

**배운 점**:
- 읽기/쓰기 패턴에 따른 테이블 분리 전략
- DB Lock 경합 최소화 방법
- 성능 최적화를 위한 데이터 모델링

### Cascade와 orphanRemoval의 생명주기 관리

**적용**:
- `Lecture` → `Chapter` → `Lesson` 계층 구조에서 `CascadeType.ALL` 적용
- `orphanRemoval=true`로 부모 삭제 시 자식 자동 삭제

**주의사항**:
- 현재는 전체 삭제 후 재생성 방식으로 인한 참조 무결성 이슈 존재
- 개선 방향: 개별 CUD API로 분리하여 세밀한 제어 필요

**배운 점**:
- JPA의 생명주기 관리 메커니즘
- Cascade의 장단점 이해
- 참조 무결성 보장의 중요성

### 인덱스 전략 수립

**적용**:
- 정렬에 사용되는 컬럼에 인덱스 적용
- `enrollment_count`, `rating_average`, `created_at` 등

**배운 점**:
- 쿼리 패턴에 따른 인덱스 설계
- 정렬 성능 향상을 위한 인덱스 활용
- 인덱스의 장단점 (조회 성능 vs 쓰기 성능)

## 개선할 점

### 1. 도메인 로직의 위치

**현재 상황**:
- Service 계층에 집중된 비즈니스 로직 (유효성 검사 등)
- Entity에 비즈니스 로직이 거의 없음
- 객체지향성이 낮음

**개선 방향**:
- 도메인 로직을 Entity 또는 별도 Validator로 이동
- `publishLecture()` 같은 상태 변경 로직을 Entity 내부로 이동
- 비즈니스 규칙이 엔티티에 명확히 표현되도록 개선
- Service는 오케스트레이션 역할에 집중

### 2. Soft Delete 도입

**현재 상황**:
- 강의 삭제 시 DB에서 바로 지우는 Hard Delete 방식
- 실수 방지 및 데이터 보존 측면에서 부족

**개선 방향**:
- `deletedAt` 필드 추가
- 삭제 시 실제 삭제가 아닌 플래그만 변경
- 데이터 복구 가능성 확보
- 통계 및 분석 데이터 보존

### 3. 대량 트래픽 대비

**현재 상황**:
- 커리큘럼 생성이 단 번에 너무 많은 요청을 처리
- 대량 데이터 생성 시 트랜잭션 시간 증가

**개선 방향**:
- 커리큘럼 생성 과정을 사용자 레벨에서 분할
- 트래픽 분산을 위한 비동기 처리 고려
- 배치 처리 방식 도입 검토

### 4. 커리큘럼 수정의 복잡도

**현재 상황**:
- 전체 삭제 후 재생성 방식 (Delete-Insert)
- `CompletedLesson`(수강 기록)의 참조 무결성 이슈
- 기존 데이터 보존 불가

**개선 방향**:
- 개별 Chapter/Lesson 단위의 CUD API로 분리
- 기존 데이터와의 매칭 로직 구현
- 수강 기록과의 연관관계 보존
- 2차 스프린트 목표로 설정

### 5. 테스트 작성 부족

**현재 상황**:
- 단위 테스트 거의 없음
- 통합 테스트도 부족
- 수동 테스트에 의존

**개선 방향**:
- 핵심 비즈니스 로직에 대한 단위 테스트 작성
  - `publishLecture()` 조건 검증 테스트
  - 커리큘럼 생성 로직 테스트
  - 예외 상황 테스트
- Service Layer 통합 테스트
  - 트랜잭션 롤백 검증
  - 도메인 간 연동 테스트

## 잘한 점

### 1. 성능 최적화

**방법**:
- N+1 문제 해결을 위한 쿼리 최적화
- 통계 데이터 분리로 Lock 경합 최소화
- 인덱스 전략 수립

**구체적 적용**:
- 쿼리 횟수를 `1 + N + N`에서 `1 + 1 + 1`로 감소
- 통계 업데이트 시 `Lecture` 테이블에 Lock이 걸리지 않음
- 정렬 성능 향상

**결과**:
- 대량 데이터 조회 시 성능 향상 체감
- 확장 가능한 구조 확보

### 2. 복잡한 계층 구조의 객체지향적 모델링

**상황**:
- Lecture → Chapter → Lesson의 3단계 계층 구조
- JPA로 매핑하여 객체지향적으로 표현

**긍정적 결과**:
- 복잡한 커리큘럼 구조를 직관적으로 모델링
- Cascade와 orphanRemoval로 생명주기 관리 자동화
- 트랜잭션 일관성 보장

**배운 점**:
- 객체지향 설계의 중요성
- JPA의 연관관계 매핑 활용
- 복잡한 도메인 모델링 경험

### 3. 아키텍처 선택의 트레이드오프 이해

**상황**:
- 초기 설계에서 아키텍처에 너무 많은 시간을 쏟지 않고 기능 구현 우선
- Monolithic 구조로 시작하여 리팩토링을 통한 확장 계획

**긍정적 결과**:
- 빠른 개발 속도 확보
- 실제 동작하는 시스템 완성
- 점진적 개선의 경험

**배운 점**:
- 완벽한 설계보다 동작하는 시스템의 가치
- 리팩토링을 통한 점진적 개선의 중요성
- 트레이드오프 판단 능력

## 개인적인 성찰

### 아키텍처 설계 시간 vs 기능 구현 우선순위

**깨달은 점**:
- 초기 설계에서 간단한 구조의 프로젝트를 아키텍처에 너무 많은 시간을 쏟기보다, 기능 구현을 우선하고 리팩토링을 통해 재조립 후 확장이 더 장점이 있다고 생각
- 완벽한 설계를 추구하기보다 동작하는 시스템을 먼저 만드는 것이 중요

**현실**:
- 아키텍처 선택에 대한 고민과 실제 구현 사이의 균형
- 시간 제약 내에서 최선의 선택을 해야 하는 상황

### 점진적 개선의 중요성

**문제점**:
- 처음부터 완벽한 구조를 만들려는 시도
- 모든 것을 한 번에 해결하려는 욕심

**비유**:
- 기초 없이 복잡한 구조를 설계하려는 것과 같은 접근
- 점진적 학습이 아닌 성급한 적용 시도

**깨달음**:
- 동작하는 시스템을 먼저 만들고, 리팩토링을 통해 점진적으로 개선
- 완벽하지 않더라도 제대로 동작하는 것이 우선
- 피드백을 받으며 개선해 나가는 과정의 중요성

### 성능 최적화 경험

**계기**:
- N+1 문제를 직접 경험하고 해결하는 과정
- 통계 데이터 분리로 인한 성능 개선 체감

**깨달음**:
- 이론으로만 알고 있던 문제를 실제로 경험
- 성능 최적화를 위한 다양한 전략 학습
- 실제 성능 개선의 가치 체감

### 앞으로의 방향

**다짐**:
- 성능 최적화에 대한 지속적인 학습
- 도메인 로직 캡슐화 강화
- 테스트 코드 작성 습관화
- 점진적 개선을 통한 성장

아직 과정이 끝나지 않았기에, 앞으로도 꾸준히 개선해 나갈 것이다.

## 프로젝트 성과

### 핵심 성과
- **Lecture 도메인 완전 구현**
  - Lecture, Chapter, Lesson 엔티티 설계
  - 커리큘럼 관리 시스템 구축
  - 상태 관리 및 공개 조건 검증
  
- **성능 최적화**
  - N+1 문제 해결로 쿼리 최적화
  - 통계 데이터 분리로 Lock 경합 최소화
  - 인덱스 전략 수립

- **도메인 간 연동**
  - Content 도메인과의 연동 설계
  - Enrollment 도메인과의 통계 연동
  - GCP Storage 연동 기반 마련

## 다음 프로젝트를 위한 목표

이번 프로젝트의 경험을 바탕으로 다음 프로젝트에서는 다음과 같은 목표를 세웠다.

### 협업 목표
1. **문서화 습관**
   - API 문서 작성
   - 설계 의도 기록
   - README 상세화

2. **적극적 소통**
   - 진행 상황 공유
   - 블로킹 이슈 즉시 알림
   - 코드 리뷰 적극 참여

3. **점진적 개선**
   - 완벽한 설계보다 동작하는 시스템 우선
   - 리팩토링을 통한 지속적 개선
   - 피드백 수용

### 학습 목표
1. **DDD 심화**
   - 도메인 로직 캡슐화 강화
   - Aggregate 패턴 심화 학습
   - Domain Event 학습

2. **JPA 최적화**
   - Fetch Join 전략
   - Entity Graph 활용
   - 2차 캐시 이해

3. **성능 최적화**
   - 쿼리 최적화 기법 심화
   - 인덱스 전략 수립
   - 대량 트래픽 대비

## 결론

이번 프로젝트에서 **Lecture 도메인을 처음부터 끝까지 설계하고 구현**하는 경험을 했다. 단순히 CRUD를 구현하는 것이 아니라, **복잡한 계층 구조를 객체지향적으로 모델링**하고, **성능 최적화를 위한 전략을 수립**하는 것이 얼마나 중요한지 깨달았다.

특히 **N+1 문제 해결**과 **통계 데이터 분리**를 통해, 이론으로만 알고 있던 성능 최적화 기법을 실제로 적용해보는 좋은 경험이었다. 쿼리 횟수를 크게 줄이고, Lock 경합을 최소화함으로써 확장 가능한 구조를 만들 수 있었다.

아키텍처 선택에 대해서는 **완벽한 설계보다 동작하는 시스템을 먼저 만드는 것**의 중요성을 배웠다. Monolithic 구조로 시작하여 리팩토링을 통해 점진적으로 개선해 나가는 접근이 더 현실적이고 효과적임을 깨달았다.

개인적으로는 **점진적 개선의 중요성**을 실감했다. 처음부터 완벽한 구조를 만들려는 시도보다, 동작하는 시스템을 먼저 만들고 피드백을 받으며 개선해 나가는 과정이 더 가치 있다는 것을 배웠다.

아쉬운 점은 **도메인 로직이 Service 계층에 집중**되어 있고, **테스트 코드 작성이 부족**하다는 것이다. 다음 프로젝트에서는 **도메인 로직을 Entity로 이동**하고, **적절한 수준의 테스트를 적용**하여 더 완성도 높은 코드를 작성하고 싶다.

결과적으로 **동작하는 Lecture 도메인**을 완성했고, **성능 최적화를 통한 확장 가능한 구조**를 만들었다. 무엇보다 **복잡한 도메인 모델링**과 **성능 최적화**를 실전에 적용하며 배운 것들이 앞으로의 개발에 큰 자산이 될 것이라 확신한다.

완벽하지 않더라도 제대로 동작하는 시스템을 만들고, 점진적으로 개선해 나가며, 한 걸음씩 성장해 나가겠다.
