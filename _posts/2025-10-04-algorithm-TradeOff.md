---
layout: post
title:  "알고리즘 문제를 풀 때 복잡도의 trade-off(내 생각)"
date:   2025-10-07 20:00:00 +0900
categories: Algorithm,Computer Science,Optimization
---

# 알고리즘 문제를 풀 때 복잡도의 trade-off

## 시작: 알고리즘 최적화에 대한 의문

예전에 알고리즘을 한참 풀때는 그냥 습관적으로 풀었는데, 최근에 알고리즘 문제 풀면서 드는 의문이 **"시간과 공간 을 어떻게 적절하게 해서 문제를 풀어야 할까?"** 라는 의문이 커졌다. 

이 질문에서 시작된 나의 생각은 가장 비교하기 익숙한 정렬 알고리즘들을 기준으로 생각하면서 구체화 해봤는데, 단순히 "빠른 알고리즘"을 찾는 것이 아니라, **명확한 알고리즘 선택에 대한 판단근거**를 생각하고 싶었는데, 일단 해당 정리에서 고려 사항은 기존의 공간복잡도의 개념과 다르다는 것이다.

> 기존의 공간 복잡도는 실제 문제에 대해 해결을 하면서, **새롭게 할당하는 공간** 을 공간 복잡도로 보고, 기존의 자료가 정의된 공간에 대해서는 배제하는데, 문제를 풀 때 문제에 제시된 공간 은 이미 유저가 사용하고 있어서 나는 해당 부분을 공간복잡도의 요소로 포함하고 판단하고 싶었다. 이 부분을 **메모리 점유**라는 개념으로 하고자 한다.
> 해당 전제를 기반으로 생각해본 부분이다.

## 1. 정렬 알고리즘 분석에서 발견한 패턴

### 정렬 알고리즘의 복잡도 비교

다양한 정렬 알고리즘들을 생각해 보았다.

| 알고리즘 | 시간 복잡도 | 공간 복잡도 | 메모리 점유 | 구조적 특성 | 안정성 | 캐시 효율 |
|---------|------------|------------|--------------|------------|--------|----------|
| 버블정렬 | O(n²) | O(1) | O(n) | 순차 접근 | 안정 | 좋음 |
| 선택정렬 | O(n²) | O(1) | O(n) | 순차 접근 | 불안정 | 나쁨 |
| 삽입정렬 | O(n²) | O(1) | O(n) | 순차 접근 | 안정 | 좋음 |
| 병합정렬 | O(n log n) | O(n) | O(2n) | 이진 분할 (log n 깊이) | 안정 | 보통 |
| 퀵정렬 | O(n log n) | O(log n) | O(n) | 이진 분할 (log n 깊이) | 불안정 | 매우 좋음 |
| 힙정렬 | O(n log n) | O(1) | O(n) | 힙 트리 (log n 높이) | 불안정 | 나쁨 |


## 2. "논리적 복잡도"라는 새로운 관점

### 구조적 특성의 발견

정렬 알고리즘들을 보면서 `알고리즘의 트레이드-오프 란 시간과 공간의 복잡도를 적절하게 곱으로 나누는것?` 이라는 생각이 들었고, 그래서 처음에는 힙 소트,퀵 소트, 머지소트가 시간과 공간의 개념에서 log n 이라는 이득을 보고있다는 생각이 들었는데, 
추가로 든 생각이 시간과 공간 복잡도 외에 **"논리적 구조"**라는 또 다른 차원이 있다는 생각이 들었다:

- **힙정렬**: 배열을 힙 자료구조인 트리 형태로 정의하는것이 트리의 높이인 O(log n) 이라는 논리적 구조
- **퀵정렬**: 피벗이 적절한 중앙값의 근처일때, 피벗을 기준으로 분할정복으로 호출하는 횟수가 O(log n) 이라는 논리적 구조
- **병합정렬**: 퀵정렬과 마찬가지로, 재귀적 이진 분할 단계가 O(log n) 이라는 논리적 구조의 높이

이런 구조적 차이가 알고리즘의 효율성의 핵심이라는 생각이 들었다.

## 3. "Problem's total resource" 라는 의문

### 3.1 초기 의문

이러한 생각에서 어떤 문제 x는 total resource 라는 값이 존재하지않을까? 그 문제 x의 알고리즘의 (시간복잡도 × 메모리점유 × 구조적복잡도)가  일정한 값을 가진다면, **이를 최대한 균등하게 분배하는 것**이 내가 문제를 풀 때 할 접근인가? 라는 의문을 가졌습니다.

최대한 균등한 분배라는 질문의 이유는 수학적 근거로 산술-기하 평균을 기반으로 생각 
A × B = 상수일 때, A = B에서 A + B가 최소가 되고 resouce 를 분배해서 합산하더라도 공간 O(1) 과 시간 O(1)의 가치가 같다면, 합산하는게 최적화 아닐까 라는 생각이 들었습니다.

### 3.2 의문의 한계와 교정

하지만 이 생각은 현실과는 맞지 않았는데, 왜냐하면

**시간 × 공간이 상수라는 전제가 성립하지 않음**
- 힙정렬: O(n log n) × O(1) = O(n log n)
- 병합정렬: O(n log n) × O(n) = O(n² log n)
- 각각 다른 "곱"을 가짐

하지만 내가 제시한 알고리즘 문제에 대한 관점으로 생각해 본다면, 그럴 수 있지 않을까 하는 생각을 한다.
아직은 내가 이 생각을 가지고 문제를 풀어보지않아서 반례가 없어 확신은 못하지만 당분간은 이 생각으로 문제를 풀지 않을까 하는 생각을한다.

하지만 정확히 현대적인 복잡도의 개념으로는 **Pareto frontier** 개념을 사용하고, 각 문제마다 고유한 trade-off 곡선이 존재한다고 한다. 

> Pareto frontier 라는 개념을 정확히 모르겠어서 나중에 추가로 찾아보려고 한다. 
> 추천 키워드 : 
> - "다목적 최적화 (Multi-objective optimization)"
> - "파레토 효율성 (Pareto efficiency)"
> - "Time-space tradeoff in algorithms"
> - "Algorithm design paradigms tradeoff"


## 4. 결론: 적절한 균형

**가져갈 생각들:**
- 시간-메모리점유량 트레이드오프의 중요성
- 구조적 패턴(재귀, 트리, etc...)을 사용한 효율성 및 문제의 resource 축소
- 복잡도를 체계적으로 분석하는 자세

> 시간 효율 극대화 자료구조 : 
  - hashTable(공간을 무한히 늘리면 시간이 O(1))
> 공간 효율 극대화 알고리즘 : 
  - 배열을 사용하지 않은 동적계획법(DP의 점화식 구축에 사용되는 인자만 기억한다면 공간이 O(1))
  - 피보나치 수열 - dp[n] 배열 대신 prev, curr 두 변수만 사용
  - 최대 부분합 - 전체 배열 저장 없이 현재까지의 최대값만 유지

> 추가1. 최근에 자바를 배우고 있어 생각난 적절한 trade-off 의 예시
- 실제 사례: Java HashMap의 적응형 구조
- Java의 HashMap은 trade-off의 실제 구현 사례:
- 기본: HashTable (O(1) 평균 시간)
- 충돌이 많을 때: Tree로 변환 (O(log n) 보장)

> 추가2. 실제 성능에서 중요한 요소:
- **Cache 지역성**: 퀵정렬이 병합정렬보다 실제로 빠른 이유 중 하나는 메모리 접근 패턴이 캐시 친화적이기 때문. 같은 O(n log n)이라도 실제 성능은 다를 수 있음
- 퀵정렬은 제자리정렬이라 캐시사용등을 통해 빠르지만, 병합정렬은 메모리할당, 스택추가 등의 오버헤드가 발생


> 추가3. 앞으로의 접근

```
문제를 만났을 때:

1. 이론적 하한 체크
   "이 유형의 문제는 보통 O(?)이지?"

2. 제약 조건 분석
   "시간/공간 제한이 어떻게 되지?"

3. 알려진 최적 알고리즘 떠올리기
   "이 문제와 비슷한 건 어떻게 풀었지?"

4. Trade-off 고려
   "메모리를 좀 쓰면 더 빨라질까?"

5. 구조적 특성 활용
   "log n 구조를 쓸 수 있을까?"
   "해시를 쓰면 O(1)이 될까?"
```

## 5. 마무리

이 생각으로 구체화 한 건 **"최적의 알고리즘"은 상황에 따라 달라진다** 

현실이든, 알고리즘 문제든 단순히 "빠른 알고리즘"을 찾는 것이 아니라, **문제의 특성, 제약 조건, 하드웨어 환경을 종합적으로 고려하여 가장 적합한 균형점을 찾는 것**

> 참고  
- 파이썬 기준  
  - 대략적 256 MB 제한 : (O(n) : 9M 이내) / (O(n^2) : 3K 이내) (근데 이 부분은 좀 애매한게 파이썬은 정적배열이 아닌 동적배열이고, 기본적으로 사이즈 할당시, 해당 사이즈의 70%? 이상 자료가 존재할 경우 1.125배 확장하는 특성이 있어 명확하게 명시가 어렵)
  - 대략적 1초 제한 : (O(n) : 2 * 10^7) / (O(n^2) : 5 * 10^3) 
