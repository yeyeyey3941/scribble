---
layout: post
title:  "FastAPI + PostgreSQL 비동기 처리 구조"
date:   2025-06-22 20:00:00 +0900
categories: fastapi
---
# 1. FastAPI + PostgreSQL 비동기 처리 구조와 교착 상태 정리

**FastAPI와 PostgreSQL을 비동기 방식으로 연동할 때** 내부 동작 구조와 교착 상태 발생/처리 방식

---

## 1. 시스템 구성 개요

| 구성 요소                  | 설명                           |
| ---------------------- | ---------------------------- |
| **FastAPI**            | 비동기 Python 웹 프레임워크 (ASGI 기반) |
| **SQLAlchemy (async)** | ORM, 비동기 DB 세션 지원            |
| **asyncpg**            | PostgreSQL용 비동기 드라이버         |
| **PostgreSQL**         | ACID 보장하는 고성능 RDB            |

---

## 2. 처리 흐름 요약

```text
[유저 요청]
 → Session (요청 단위 DB 세션) 생성
 → SQLAlchemy ORM으로 쿼리 구성
 → asyncpg + Engine 통해 PostgreSQL에 SQL 전송
 → PostgreSQL이 자원에 락을 걸고 처리
 → 결과 반환 → 세션 종료
```

* FastAPI는 **비동기 코루틴으로 대기 없이 다른 작업 전환 가능**
* PostgreSQL은 락 충돌 시 대기하거나, 교착 상태 감지

---

## 3. 동시에 커밋이 들어올 경우?

### 예시 상황

* **세션 A**: row1 → update → commit
* **세션 B**: row1 → update → commit (동시 진입)

### 처리 흐름

| 세션 A             | 세션 B                    |
| ---------------- | ----------------------- |
| row1에 락 → update | row1 락 요청 → 대기          |
| commit 완료 → 락 해제 | 대기 종료 → update → commit |

PostgreSQL은 **row-level lock**을 사용해 **충돌된 자원은 순차 처리**

#### row-level lock이란?

- row-level lock은 행 단위로 락을 걸어 순차처리하는 락 방식
- lock을 걸고 있는 행에 대해서는 다른 트랜잭션이 접근 불가
- lock을 대기하는 큐도 row-level로 관리됨
- 겹치지 않는 행에 대해서는 코루틴 처럼 병렬 처리 가능
- 대기큐의 갯수 제한은 없지만, 대기중인 세션도 커넥션을 차지하기 때문에 커넥션 풀 제한을 넘어서면 안됨

---

## 4. 교착 상태(Deadlock)란?

### 발생 조건

두 트랜잭션이 **서로 다른 리소스를 점유하고**, 상대 자원을 기다릴 경우 발생

| 세션 A              | 세션 B              |
| ----------------- | ----------------- |
| row1 락 → row2 기다림 | row2 락 → row1 기다림 |

→ 서로 기다리는 교착 상태 발생

### PostgreSQL의 대응

* 내부 **Deadlock Detector**가 주기적으로 탐색
* 교착 상태가 감지되면 **트랜잭션 중 하나를 강제 종료**

---

## 5. 교착 상태 방지 전략

| 방법                  | 설명                      |
| ------------------- | ----------------------- |
| **자원 접근 순서 고정**     | 항상 row1 → row2 순서로 접근 등 |
| **재시도 로직 적용**       | 에러 발생 시 자동으로 재시도        |
| **`FOR UPDATE` 사용** | 비관적 락으로 선점              |
| **낙관적 락 (버전 관리)**   | 충돌 시점에 에러로 감지           |

---

## 6. 세션 vs 엔진 vs DB 관계

| 구성             | 역할                     |
| -------------- | ---------------------- |
| **Session**    | 요청당 하나 생성, 트랜잭션 단위 컨트롤 |
| **Engine**     | 커넥션 풀 및 쿼리 실행 관리       |
| **PostgreSQL** | 실제 트랜잭션/락 처리 주체        |

* Session은 쿼리를 Engine에 넘기고,
* Engine은 DB에 실행을 위임하며,
* **락, 트랜잭션 처리의 주체는 DB**

---

## 7. 비동기 환경에서도 결국 동기처럼 보이는 이유?

* **같은 자원을 수정하려는 요청은 충돌이 발생**

  * 이 경우, 대기 큐(FIFO) 방식으로 처리되어 동기처럼 보임
* **다른 자원에 대한 요청은 진짜 병렬 처리됨**

>  **"비동기란 겹치지 않는 자원에 대해 동시에 병렬적으로 처리 가능"**

---

## 8. PostgreSQL은 진짜 비동기 DB인가?

### 정답: **X. 동기 기반 멀티프로세스 구조**

| 항목       | 설명                             |
| -------- | ------------------------------ |
| 클라이언트 연결 | 프로세스 단위로 관리 (각 클라이언트별 독립 프로세스) |
| 동시성      | 여러 쿼리를 병렬로 실행 가능 (멀티코어 기반)     |
| 비동기 처리   | 쿼리 결과를 비동기적으로 기다리는 방식은 지원 가능   |

### 따라서:

* 비동기 처리는 **FastAPI ↔ DB 사이의 요청 관점에서 의미**
* PostgreSQL 내부는 여전히 동기적 트랜잭션 처리 기반

---

## 9. 시스템 병목은 어디서 발생할까?

| 병목 구간    | 원인                      |
| -------- | ----------------------- |
| DB 락 충돌  | 자원 공유 시 병렬성 상실          |
| 커넥션 풀 한계 | DB 연결 수 제한              |
| CPU 자원   | 비동기 처리라도 결국 연산은 물리 코어에서 |
| 네트워크 대역폭 | 대량 트래픽 시 응답 지연          |

---

## 마무리 정리

* FastAPI + SQLAlchemy + asyncpg는 **비동기 I/O 기반의 고성능 구조**
* 교착 상태는 **DB 수준에서 발생**하며, 적절한 예외 처리 및 자원 설계로 예방 가능
* PostgreSQL은 비동기 DB가 아닌, **멀티프로세스 기반 동기 트랜잭션 처리 시스템**
* 비동기의 핵심은 \*\*"대기 중 낭비를 줄이고, 다른 요청을 병렬로 처리하는 구조"\*\*에 있음
